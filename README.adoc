= helidon
:toc: auto

Sample Helidon MP project that includes multiple REST operations.

== Build and run

With JDK21
[source,bash]
----
mvn package
java -jar target/helidon.jar
----

== Exercise the application

Basic:
[source,bash]
----
curl -X GET http://localhost:8080/simple-greet
Hello World!
----

JSON:
[source,bash]
----
curl -X GET http://localhost:8080/greet
{"message":"Hello World!"}

curl -X GET http://localhost:8080/greet/Joe
{"message":"Hello Joe!"}

curl -X PUT -H "Content-Type: application/json" -d '{"greeting" : "Hola"}' http://localhost:8080/greet/greeting

curl -X GET http://localhost:8080/greet/Jose
{"message":"Hola Jose!"}
----

== Try metrics

[source,bash]
----
# Prometheus Format
curl -s -X GET http://localhost:8080/metrics
# TYPE base:gc_g1_young_generation_count gauge
. . .

# JSON Format
curl -H 'Accept: application/json' -X GET http://localhost:8080/metrics
{"base":...
. . .
----

== Try health

[source,bash]
----
curl -s -X GET http://localhost:8080/health
{"outcome":"UP",...
----

== Building a Native Image

The generation of native binaries requires an installation of GraalVM 22.1.0+.

You can build a native binary using Maven as follows:

[source,bash]
----
mvn -Pnative-image install -DskipTests
----

The generation of the executable binary may take a few minutes to complete depending on your hardware and operating system. When completed, the executable file will be available under the `target` directory and be named after the artifact ID you have chosen during the project generation phase.

== Building the Docker Image

[source,bash]
----
docker build -t helidon .
----

== Running the Docker Image

[source,bash]
----
docker run --rm -p 8080:8080 helidon:latest
----

Exercise the application as described above.

== Run the application in Kubernetes

If you don’t have access to a Kubernetes cluster, you can link:https://helidon.io/docs/latest/#/about/kubernetes[install one] on your desktop.

=== Verify connectivity to cluster

[source,bash]
----
kubectl cluster-info                        // Verify which cluster
kubectl get pods                            // Verify connectivity to cluster
----

=== Deploy the application to Kubernetes

[source,bash]
----
kubectl create -f app.yaml                  // Deploy application
kubectl get pods                            // Wait for quickstart pod to be RUNNING
kubectl get service  helidon         // Get service info
----

Note the PORTs. You can now exercise the application as you did before but use the second port number (the NodePort) instead of 8080.

After you’re done, cleanup.

[source,bash]
----
kubectl delete -f app.yaml
----

== Building a Custom Runtime Image

